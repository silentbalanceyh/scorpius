## 2.02 OO、OP、OC、SOA、AOP

### 基础概念

#### 1.Oriented Object【面向对象】

<font style="color:red">*：前边一个章节已经讲解过面向对象的编程设计，这里就不详细讲解了，那么这个章节主要通过不同的编程设计方法来理解不同的程序设计方法论的区别，并且让读者在面向对象的设计理论基础上去理解不同的软件设计方法论以及软件设计的方法的一种演化。</font>

#### 2.Oriented Procedure【面向过程】

计算机语言诞生的时候，最初的程序设计都是以“函数链”的方式来完成的程序设计，实际上OP的设计方法和OO的设计方法是面对同一个事情的不同的侧重点的设计，先看一个例子来理解一下“过程”和“对象”的区别。

	学生给老师打电话

这个是一个很简单的场景，但也足够区分OO和OP的程序设计方法了，那么先看看如何使用OO和OP的方式来设计上边的业务场景【下边两种思路仅做参考和举例以对比OO和OP的一些细枝末节，这些设计思路并不一定是OO或者OP的最优化设计】。

**OO设计**

* 对象定义：学生、老师、电话
* 对象交互：学生 -> 电话、学生 -> 老师
* 交互限制：学生 -> 老师[Depend On：学生 -> 电话]

从面相对象的设计上来考虑，上边的侧重点在于先**定义对象**，所以上边的业务需求从OO的设计【Oriented Object】中的流程按照下边的方式进行。

1. 抽象一个类`Person`，这个类可以作为`学生`和`老师`的抽象类而存在；
2. 从`Person`这个类中写两个继承类`Student`和`Teacher`；
3. 单独定义一个类`Phone`作为电话这个对象的类；<br/><font style="color:blue">【*：上边的三步就完成了一个简单的对象定义。】</font>
4. 定义对象`Student`和`Phone`之间的关系，完成从`Student -> Phone`的对象交互设计；
5. 定义对象`Student`和`Teacher`之间的关系，完成从`Student -> Teacher`的对象交互设计；
6. 定义`Student`和`Teacher`之间交互的限制条件，就是发生在`Student -> Phone`这个行为之后，实际上这里所定义的就是一种“限制”，也就是说`Student -> Teacher`的交互是取决于`Student -> Phone`的交互结果，简单说：`如果学生要给老师打电话，那么前提是学生首先需要和电话进行交互并且交互成功。`

上边的思路就是以OO的方式去设计这样的一个业务场景，在这种设计中不存在函数概念，在OO中“函数”这个概念被对象的“操作”和“事件”替换掉了。也就是说函数最终的呈现模式和对象的“操作”和“事件”直接挂钩，它们的形态是一致的，只是“函数”存在全局函数，而对象的“操作”却不存在全局的，“操作”和“事件”的讨论是基于对象的，而“函数”却是自由的，除此之外基于过程的“函数链”的设计方式和基于对象的“操作/事件”的设计方式还会有很多的不同之处【OO vs OP】。不知道这样讲读者是否能够理解，在看这些不同之前再通过OP的方式来设计上边的业务场景，最终来对比一下OP和OC的区别以理解曾经的面向过程的设计方法。

**OP设计**

* 过程定义：拿电话、打电话
* 过程输入：拿电话[Input：学生、电话]、打电话[Input：学生、老师]
* 过程依赖：打电话[Depend On：拿电话]

如果使用的是面向过程的设计，那么侧重点就是**定义过程**，所以上边的业务需求从OP的设计【Oriented Procedure】流程应该按照下边的方式进行。

1. 定义一个两个过程`Procedure`，一个是拿电话：`TakePhone`，一个是打电话：`Call`；
2. 定义拿电话`TakePhone`的两个输入数据：`Student，Phone`以及输出的状态：`成功`或`失败`；
3. 定义打电话`Call`的两个输入数据：`Student, Teacher`以及输出的结果；
4. 定义`TakePhone`和`Call`两个过程之间的限制条件以及依赖关系；

上边这样的设计方法就是基于OP的方式去设计同样的一个业务场景，这种设计中所关注的并不是对象，而是过程细节【动作】，而原来在OO中的对象在这种设计中会作为过程的输入以及输出来处理，这种OP的设计可以抽象成上边提到的“函数链”的方式，实际上这里的设计可以看做函数的依次调用：`先调用TabePhone、再调用Call`。

**OO vs OP**

上边针对同样的一个业务场景，进行了简单的OO和OP的设计与分析，那么看看这两种设计的区别：

* OO设计的侧重点是对象，而OP设计的侧重点是过程，前者一般在场景中是以“名词”描述，表示一个静态的具有属性和操作的事物的集合；后者一般在场景中是以“动词”描述，表示一个动态的动作的集合，主要描述交互内容和流程；
* OO设计关注的是整个场景中的事物，然后才会去关注事物和事物之间的交互，而系统最终是建立在对象以及对象交互基础上的；而OP设计关注的是整个场景中出现的交互，然后考虑的是第一步执行什么过程、下一步执行什么过程，最终系统是建立在过程、过程输入和输出数据基础上的。

从上边的例子可以知道，OO和OP本质上有很大的区别，虽然设计系统的时候最终都是殊途同归，但设计的方法、细节、侧重点却出现了很多不同的地方，而主要是一个思维的差异，希望读者根据上边的例子去理解OO和OP的两种不同的系统设计方法论。

#### 3.Oriented Component【面向组件】

组件这个概念是在对象基础之上出现的，组件的粒度比对象的粒度大很多；在面向对象设计的系统里，对象是构成系统的基本元件，而在面向组件设计的系统里，组件则是构成系统的基本元件。组件从某种意义上讲属于系统的一个“子系统”，它由许多不同的对象协作而组成，主要目的是面向“业务单元”，它既包含许多对象的集合，同时在这个“子系统”内部它还包含了对象和对象本身的交互，在现在的很多系统设计里，面向组件设计更多的是基于“接口设计”而诞生的。

组件集中关注的是业务的职责，明确业务边界，从这点意义上讲面向组件设计更符合系统满足业务功能需求的方法。

组件还有一个设计目的是实现重用：如果业务复杂的话，同一个概念实体，可能包含1000个属性，而这个1000个属性实际上是可以分类的，如果仅仅使用面向对象的设计方法，那么就意味着针对这1000个属性的操作设计会封装在这一个对象中，结果导致所有的操作因为和属性绑定而使得这一个对象是无法重用的，这是一种设计上的缺陷。而面向组件设计刚好改善了这样的一种情况，它会根据1000个属性不同的“业务职责”分类成不同的业务组件，而不是封装在一个独立的对象中，同时公用部分的属性会作为接口被开放出来被其他组件所重用，并且还针对私有部分的对象交互封装在组件内部，对外实现了“信息隐藏”。

从面向组件的描述上看，面向组件设计也包含了面向对象设计的一些基本概念，比如“封装”，实际上面向组件的程序设计是基于面向对象的，算是面向对象的一种演变；在基于组件设计的系统基础上，虽然它把一些可重用的组件以业务接口的方式开放出来了，但是强调的是组件复用，而不是接口设计，只是这种组件的复用会使得设计潜移默化地向接口设计中执行迁移。

* 在面向对象的系统中，它的基本元件是对象，对象主要是面向实体/属性集/模型，而不是面向“业务职责”；
* 在面向组件的系统中，它的基本元件是组件【一个对象的集合】，组件主要是面向“业务职责”的，而“业务职责”不是一个对象可以完成的，有可能是多个对象的结合才能实现一个完成的“业务职责”；

除了上边提到的几点以外，面向组件的设计方法会有“容器”的概念：<font style="color:blue">在面向组件的系统里，组件的正常工作是需要容器帮助的，容器会为组件提供一个完整的运行环境使得这个组件在一个比较抽象的较高的平台上完成自己最擅长的工作而不去考虑底层的细节问题。</font>在组件中往往需要实现的是一些和容器相关的回调方法，比如数据库访问组件不会去关心它所面向的数据库的类型是什么，往往只关系访问数据库的基本读写方法，但是容器可以给组件提供底层的实现细节，而组件本身只是需要配合容器操作就可以了。不仅仅容器也可以向组件提供一些公用接口，让组件本身可以去使用容器提供的服务，比如事务管理、安全管理等。

初次之外面向对象的生命周期是由平台管理，比如JVM会管理所有Java对象的生命周期，而面向组件设计的组件生命周期却不是由JVM这种平台来管理，反而是由容器来管理，那么组件的状态、持久性、通信方式自然成为了容器最初设计需要考虑的一种职责问题，因此才会出现组件分类。

<font style="color:green">
先对OP、OO、OC做个简单的总结：

* OP：最初的软件设计是以“干什么”为主，就是将一个任务分拆成许多子任务，然后每一步做什么进行函数封装，这种情况下软件设计就是以OP为主，它所关注的是任务怎么去完成以及实现细节。这样的设计有一个缺陷就是输入和输出会变得相对混乱，无法管理。比如有时候不得不引用一些全局变量来完成这个过程的编写，而全局变量不容易被管理并且其影响范围特别大，所以随着软件设计的发展，在设计系统的时候尽可能避免使用全局变量。
* OO：为了使得设计的软件系统更加清晰、易于管理，出现了基于对象的设计，即面向对象设计【OO】，而面向对象的侧重点主要是以对象为主，它通过一种简单易懂的方式将很多不同的任务抽象成了对象和对象之间的交互，那么在这样的情况下对象是易于管理的，而这种设计方法使得系统设计变得更加易于理解、维护甚至后期的扩展。而且因为对象引入了属性、操作、生命周期等一系列的概念，就使得基于面向对象设计的系统更容易反应真实的世界以及真实的业务需求。
* OC：随着真实需求的不断扩大和复杂化，软件设计更加倾向于可重用的原则，实现真正的模块化设计，在一个软件系统里模块、组件这种基于对象的高度抽象部分是可实现重用的，而且真正实现一次性开发而不重复制造轮子的理想化软件开发流程。在这样的推动下就出现了面向“业务职责”的软件开发方法，即OC，这里的每个组件、模块都可以完成一个独立的“业务需求”，并且这些独立的组件是可重用的，面对同一个业务需求可以在任何一个不同的系统里去完成同样的事情而实现高度复用。

所以OP到OO再到OC也鉴证了软件领域中系统设计的发展流程。
</font>

#### 4.Service Oriented Architecture【面向服务架构】

面向服务的体系架构是一个组件模型，它将应用程序的不同功能单元【在OC中称为一个组件或模块，而在SOA中就是一个服务】通过这些服务之间定义良好的接口和契约联系起来从而实现契约式的编程方法。如果OO是强调将系统对象化并且侧重于对象和对象之间的交互，那么SOA就是强调将系统组件化并且侧重于组件和组件之间的交互，对象和对象之间的交互契约一般面向对象的设计语言都是支持的，比如Java，而组件和组件之间的契约会根据业务需求的不同有所差异，所以SOA强化了“接口”这个概念。接口是采用中立的方式进行定义，它应该独立于实现服务器的硬件平台、操作系统甚至编程语言，这样使得构建在各种各样系统中的服务可遵循一种统一通用的方式进行接口交互，而更加不关心接口后边的实现内容。

**高内聚 vs 低耦合**

内聚性和耦合性是OO出现过后就存在的一个概念，在设计一个`Class`的时候，一个类的设计好坏就依靠它的内聚性、耦合性来进行判断，看这个类是否符合高内聚、低耦合的标准。

* 内聚性【模块内部】：就是一个模块内部各个元素彼此结合的紧密程度，高内聚就表示了这个模块内部各个元素之间彼此结合的紧密程度很高，这种内聚性体现了软件设计中的“单一责任原则”，每个模块内部的元素是由很强的职责代码组成，而且这个模块只负责一项简单的任务；
* 耦合性【模块相互间】：一个软件结构内不同的模块之间互相连接程度的度量，耦合性也称为块间联系，它可以度量系统结构中各个模块之间相互联系的紧密程度。如果模块之间的联系越紧密，则耦合性就越强，模块的独立性则越差。<br/>低耦合的系统一般遵循下边的设计目标：<br/>
1）一个完整的系统，模块与模块之间，尽可能的使其独立存在；<br/>
2）每个模块尽可能地独立完成某个特定的子功能；<br/>
3）模块与模块之间的接口，尽量少儿简单；<br/>
4）如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分；

一个优秀的软件系统尽可能是：高内聚、低耦合的系统，这也是软件系统设计的核心目标；

系统的耦合性分为下边几种，下边的耦合性从高到低进行排序【越往下越好】：

1. **内容耦合**：主要包含了下列的情况之一，两个模块就发生了内容耦合：<br/>
一个模块访问另一个模块的内部数据<br/>
一个模块不通过正常入口而转到另一个模块的内部<br/>
一个模块有多个入口
2. **公共耦合**：当两个或者多个模块通过公共数据环境相互作用时，他们之间的耦合称为公共环境耦合；
3. **控制耦合**：如果两个模块通过参数交换信息，交换的信息有控制信息，那么这种耦合就是控制耦合；
4. **特征耦合**：如果被调用的模块需要使用作为参数传递进来的数据结构中的所有数据时，那么把这个数据结构作为参数整体传送是完全正确的；但是，当把整个数据结构作为参数船体而使用其中一部分数据元素时，就出现了特征耦合。在这种情况下，被调用的模块可以使用的数据多于它实际需要的数据，这将导致对数据访问失去控制，从而给计算机犯错提供了机会。
5. **数据耦合**：如果两个模块通过参数交换信息，而且交换的信息仅仅是数据，那么这种情况就是典型的数据耦合；

系统的内聚性则分为下边几种，由弱到强进行排序【越往下越好】：

1. **偶然内聚**：模块中的代码无法定义其不同的功能的调用，但它使得该模块执行不同的功能，这种模块称为巧合强度模块；
2. **逻辑内聚**：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能；
3. **时间内聚**：把需要同时执行的动作组合在一起形成的模块为时间内聚模块；
4. **过程内聚**：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递；
5. **通信内聚**：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据；
6. **顺序内聚**：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入；
7. **功能内聚**：共同完成同一功能，缺一不可，模块不可再分割；

**SOA简介**

面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用。服务层是SOA的基本，可以直接被应用调用，从而有效控制系统中与软件代理交互的人为依赖性；

SOA是一种粗粒度、松耦合服务架构，服务之间通过简单、精确定义接口进行通讯，不涉及底层编程接口和通讯模型。SOA可以看做是B/S模型、XML/Web Service技术之后的自然延伸。

SOA这种新型的系统架构模型可以帮助工程师站在一个新的高度去理解企业系统架构中的各个组建的开发、部署形式，它将帮助企业系统架构者以更迅速、更可靠、更具有重用性的方式去架构整个业务系统。较之以往，以SOA架构的系统能够更加从容地面对业务的急剧变化。

**SOA的基本特征**

SOA的实施具有几个鲜明的基本特征，实施SOA的关键目标是实现企业IT资产的最大化作用：

* 可以从企业外部访问
* 随时可以调用
* 粗粒度的服务接口分级
* 松散耦合
* 可重用的服务
* 服务借口设计管理
* 标准化的服务接口
* 支持各种消息模式
* 精确定义的服务契约

对比SOA和OP、OO、OC可以发现，SOA是在OC基础上发展而来的一种新型软件程序设计架构，它是在面向“业务职责”的时候执行了更加细粒度的规范工作，OC本身的目的是将系统进行模块化，让模块的重用率提高，并且使得组件在通过对象进行整合了过后变得更加“精致”，而SOA更倾向于实现模块内部的高度封装以及模块和模块之间的松耦合，在这种架构下以“接口”为中心去设计一个完善的系统。

实际上可以通过这样几种不同的软件设计方法看看软件设计的基本发展流程：

* OP——解决了软件干什么的问题，将现实问题抽象成一个任务目标，通过划分子任务的方式让软件去实现业务需求；<br/><font style="color:green">【编写程序完成任务，强调任务步骤】</font>
* OO——让软件对现实世界进行更加合理地抽象，以现实问题中的“物”为中心执行的统一化的抽象方案，改变了程序设计的侧重点；<br/><font style="color:green">【建立现实需求的抽象模型，强调现实世界的每一种“物”都以对象方式呈现，强调对象本身】</font>
* OC——在软件对现实世界抽象的基础之上以面向“业务职责”为目标，以“物”与“物”之间的协作而构成独立“子系统”实现模块化的系统设计；<br/><font style="color:green">【将对象进行组织，面向“业务职责”，强调“子系统”本身构成可重用的模块和组件，分类分层实现模块本身的高内聚】</font>
* SOA——强化了“子系统”和“子系统”之间的协作以及契约，在完成“业务职责”的基础之上强调了“接口”，通过“接口”的方式一方面实现了“业务需求”，另外一个方面使得系统中的各个模块在严格意义上实现更加松散的耦合性。<br/><font style="color:green">【在面向“业务职责”的基础之上，强调“子系统”和“子系统”之间的协作，以契约和接口为蓝本，实现模块和模块之间的松耦合】</font>

#### 5.Aspect Oriented Programming【面向切面编程】

AOP是OOP【Object Oriented Programming】的衍生物，它通过预编译方式和运行期动态代理的方法实现了程序功能的统一维护的技术，它是软件开发过程中的一个热点，和上边谈到的几种软件程序设计方法不一样，它是函数式编程的一种衍生范式。

在设计一个软件系统的时候，往往会从“业务职责”将软件功能分成两大部分：

* 非功能模块：可重用的和业务流程以及业务需求本身无关的跨系统共享模块【如：日志记录、性能统计、安全控制、事务管理、异常处理】；
* 功能模块：以“业务流程”为中心的系统内部可共享模块，面向业务需求设计的特殊化功能组件；

OO本身的目的是针对业务处理过程的实体以及其属性和行为进行抽象封装，实现系统中更加清晰的逻辑单元划分；而AOP则是针对业务处理过程中的切面进行提取，它所面对的是处理过程中某个步骤和阶段以获取逻辑过程中各个部分的低耦合的隔离效果。

OO虽然侧重于“对象”的设计，但对象和对象之间、业务流程的实现本身还是基于过程的，而AOP可以看作是在OO设计的系统中更加细粒度地管理过程的抽象，更加准确地说是在OO之下针对“交互”这一块进行的切面抽象。

回到最初的例子：

	学生给老师打电话

在这个业务场景中，有一种情况在上边没有考虑，就是：如果电话打不通、手机关机的情况下怎么办？——这种可以称为过程执行异常。

对现实社会而言，如果打不通就会去评估事情的紧急程度，不外乎采取三种办法：

* 如果事情紧急，那么隔几分钟Retry一次直到打通为止；
* 如果事情不紧急，等待老师回复电话Wait For Response然后转“打电话”的操作为事件；
* 若不关心结果，则打不通就算了，累死广播模式Publish/Subscription；

这里不关心`学生、老师、电话`三个对象，侧重关心“打电话”这个行为，实际上不仅仅是学生给老师打电话，只要是系统中出现了任何打电话的行为都会出现上边的三种结果，也就是说上边列举的三种结果如果不考虑打电话的发起者以及接受者，单单针对这个行为而言的话是可抽象的。考虑下边两段概念代码：

	public void call(int urgentLevel, Teacher teacher){
		if(urgentLevel == LOW)
		{
			return;
		}else if(urgentLevel == MIDDLE)
		{
			waitFor(teacher);
			// teacher.sendMsg(this);
		}else if(urgentLevel == HIGH)
		{
			boolean result = sendMsg(teacher);
			while(!result)
			{
				call(teacher);
			}
		}
	}
当然上边的代码是不完善的，而从上边的代码结构可以知道，实际上这个标准的三种分支情况的代码检查部分融入了核心逻辑中，但真正的主逻辑只有两个：`waitFor`和`sendMsg`，而其他大部分的代码完成的都是针对前边提到的三种结果的前置检查和后置检查，那么如果抽取出来会演变成什么样子呢？

AOP的目的就是为了分离上边这种情况的切面逻辑而诞生的，有了“切面”过后，所有的前置条件、后置条件的执行逻辑都可以放在“切面”中完成，而且对“打电话”这样一个简单的动作就仅仅只保留了核心业务逻辑代码，而这种情况下，`call`函数就“单一职责“化了——仅仅去完成打电话的逻辑，不关心打电话本身的前置检查【事情紧急不紧急】、后置结果【电话是否可以打通】，这些前置检查和后置检查放在了另外的一个逻辑位置去完成，就是切面。

切面有一个优势是在于代码核心逻辑本身感受不了切面的存在，但是切面会对逻辑代码进行前置拦截和后置拦截，它使用了静态预编译和动态代理的方式将代码植入到主逻辑的前后去完成了针对主逻辑过程的修改过程，这个过程会在AOP中隐式发生，而它正是为可抽象的共享过程逻辑而诞生的，并且是建立在OO的基础之上的一种编程设计方法。

<font style="color:green">*：这里就不详细介绍AOP中存在的相关概念，后边会有专程的章节来完成针对AOP的介绍以及详细讲解。</font>

<hr/>

### 总结

本章主要介绍了程序设计的几种基本方法，通过和OO【面向对象】的对比去理解不同的系统设计方法以及软件设计的开发流程，不论使用什么方法去设计这样一个系统，其目的其实是一致的，从大方向考虑，一个系统是否优劣有很多不同唯独的设计目标，而本章学习的方法就是向这些目标迈进的。其目标主要包含：

* 可靠性【Reliable】
* 安全性【Secure】
* 水平扩展性【Scalable】
* 可定制化【Customizable】
* 功能扩展性【Extensiable】
* 可维护性【Maintainable】
* 客户体验【Customer Experience】
* 市场时机【Time to Market】

这些对一个成熟并且成功的软件都是必不可少的。