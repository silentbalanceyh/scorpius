## 1.12 Array，Java中的数组[]

### __代码清单__
包：`com.sco._1st`<br/>
类清单：<br/>

* `com.sco._1st.ArrayDefine`
* `com.sco._1st.ArrayForEach`
* `com.sco._1st.ArrayMulti`
* `com.sco._1st.ArrayIterator`

### __基本概念__

数组是一组相关数据的集合，实际上就是一连串的变量，数组按照使用一般分为：`一维数组，二维数组，多维数组`，数组可以用来定义一组同类型的变量，比如定义4个int类型的变量可以用下边两种方式：
非数组方式：

	int a;
	int b;
	int c, int d;
如果使用数组就可以直接使用：

	int[] a = new int[4];

#### __1.定义__
Java语言中声明数组用的符号是`[]`，声明以及初始化语法如下：

	<Data Type> [] arrayone; // 定义一维数组
	<Data Type> arrayone []; // 定义一维数组
	<Data Type> []arraytwo[]; // 定义二维数组
	<Data Type> arraytwo[][]; // 定义二维数组
	<Data Type> [][]arraytwo; // 定义二维数组
	
关于Java语言中数组的定义和初始化需要注意的如下：

1. 在定义数组的时候，`[`和`]`必须匹配成对出现，并且不能嵌套；
2. 没出现一对`[]`就表示数组的一个维度，那么两个就表示二维数组（表空间），三个就是三维数组（立体空间），出现几次就表示几维数组；
3. `[`和`]`之间放多少空白都可以，在定义二维数组以上的时候，`[]`的位置随意，例如：`int []a[  ]`或者`int [][] a`，以及`int [] a [ ] []`都是合法的定义方式；

#### __2.初始化__
在定义了数组过后就需要进行Java数组的初始化工作，数组的初始化在Java里通常有两种方式：

__*使用字面量*__

	int a = new int[]{1,2,3,5};
	int a9[][][] = new int[][][]{{{6},{7,8,9}},{{5},{4}}};
	int a11 = {1,4,5,67}

__*定义对象*__

	int[] a = new int[4];
	int a2[][] = new int[4][1];
	int [] a3 [] = new int[1][];

注意：

* 对于多维数组的初始化，如果第一维度的长度没有指定不能直接定义第二维度的长度；` int [] a3 [] = new int [][4]`这种不会通过编译；
* 如果使用字面量初始化的话，字面量的维度需要和定义数组的维度匹配才可以；`int a6[][] = new int[][]{3,4};`这种不会通过编译；
* 初始化只能选择其中一种，不能两种同时用，原则：<font style="color:red">字面量初始化不指定长度，对象初始化必须指定至少一个维度的长度；</font>
* 在Java语言里提倡的数组初始化的格式是把`[]`写在前面形如：`int[] c = new int[4];`因为这样的话可以保证和其他类型直接区分开；

#### __3.索引和访问__
前边已经讲到了数组的定义和初始化，接下来就是关于数组中每一个元素的访问，初始化中漏掉了一种方法就是对每一个元素进行初始化工作（只针对复杂类型）。

	String[] arrayStrings = new String[3];
	for (int i = 0; i < arrayStrings.length; i++) {
		arrayStrings[i] = new String("String" + i);
	}
上边的循环语句访问了数组中的每一个元素，并且进行了初始化操作，从代码段可以看到数组访问的方式语法为：<br/>
array[index]：index的范围：<font style="color:blue">[ 0 , array.length )</font>，和所有计算机语言一样，数组的索引从0开始而不是从1开始。

#### __4.多维数组__
多维数组的使用以例子：`com.sco._1st.ArrayMulti`为主，这里只通过输出来分析Java语言中多维数组的特征：

	[14],[0],[25],
	[26],[9],[5],
	[17],[28],[10],
	------------------------
	[15],[29],
	[1],[14],[35],
	[37],
	------------------------
	[12],[33],
	[45],[44],[46],[47],
	[56],[12],[9],

* 第一个数组是固定的3 x 3的数组；
* 第二个数组是一个不规则的二维数组，行是固定的，但每一行的列数不固定（多运行几次看变化，结果不同）
* 第三个数组在创建和初始化的时候是直接赋值；

总结Java里的多维数组：

1. 多维数组可以是不规则数组，并不是严格的类似__Table__的__Row x Column__的结构；
2. 多维输出初始化使用对象方式初始化的时候低纬度的尺寸（长度）必须指定，如：二维数组定义中一维数组必须指定；
3. 多维数组进行字面量初始化的时候必须保证字面量的值符合数组维度定义；

#### __5.数组遍历__
读取数组的元素信息可以使用array[index]的方式，那么就可以使用循环通过遍历的方式来完成元素的读写操作。
##### __*一维数组*__
使用索引的遍历array[index]

	for( int i = 0; i < arr1.length; i++ ){
		System.out.printf("%d,",arr1[i]);
	}
使用JDK 1.5之后的Foreach遍历方式

	for( int i: arr2 ){
		System.out.printf("%d,",i);
	}
##### __*二维数组*__
二维数组的遍历需要注意的就是`array[row][column]`中第一个维度是行标，而第二个维度是列标，比如：

	for (int i = 0; i < arr3.length; i++) {
		for (int j = 0; j < arr3[i].length; j++) {
			// [min,max] = random.nextInt(max) % (max - min + 1) + min;
			arr3[i][j] = random.nextInt(40) % ((40 - 20) + 1) + 20;
		}
	}
5 x 6的一个随机数数组，它的输出对应如下：

	[
	32 [i=0,j=0]  , 36 [i=0,j=1]  , 37 [i=0,j=2]  , 24 [i=0,j=3]  , 28 [i=0,j=4]  , 30 [i=0,j=5]  , 
	34 [i=1,j=0]  , 35 [i=1,j=1]  , 33 [i=1,j=2]  , 38 [i=1,j=3]  , 38 [i=1,j=4]  , 37 [i=1,j=5]  , 
	30 [i=2,j=0]  , 20 [i=2,j=1]  , 28 [i=2,j=2]  , 32 [i=2,j=3]  , 36 [i=2,j=4]  , 36 [i=2,j=5]  , 
	26 [i=3,j=0]  , 31 [i=3,j=1]  , 38 [i=3,j=2]  , 23 [i=3,j=3]  , 20 [i=3,j=4]  , 22 [i=3,j=5]  , 
	38 [i=4,j=0]  , 26 [i=4,j=1]  , 38 [i=4,j=2]  , 20 [i=4,j=3]  , 31 [i=4,j=4]  , 24 [i=4,j=5]  , 
	]
从上边的例子可以知道：<font style="color:red">`i`表示行标，而`j`表示列标，这种表示方法是线性代数中的矩阵的表示法，和坐标轴的表示方法有些区别，这一点一定要谨记。</font>

从JDK 1.5过后，因为引入了`Foreach`的语法，所以还支持下边这种二维数组的遍历方式：

	int i = 0;
	for( int[] item: arr3){
		for( int j = 0; j < item.length; j++ ){
			System.out.print(arr3[i][j] + " [i=" + i + ",j=" + j + "]  , ");
		}
		System.out.println();
		i++;
	}
这种遍历方式的输出和上边输出是一致的：

	27 [i=0,j=0]  , 37 [i=0,j=1]  , 34 [i=0,j=2]  , 29 [i=0,j=3]  , 22 [i=0,j=4]  , 25 [i=0,j=5]  , 
	37 [i=1,j=0]  , 29 [i=1,j=1]  , 30 [i=1,j=2]  , 28 [i=1,j=3]  , 22 [i=1,j=4]  , 27 [i=1,j=5]  , 
	21 [i=2,j=0]  , 30 [i=2,j=1]  , 39 [i=2,j=2]  , 25 [i=2,j=3]  , 39 [i=2,j=4]  , 23 [i=2,j=5]  , 
	37 [i=3,j=0]  , 36 [i=3,j=1]  , 39 [i=3,j=2]  , 22 [i=3,j=3]  , 26 [i=3,j=4]  , 28 [i=3,j=5]  , 
	33 [i=4,j=0]  , 36 [i=4,j=1]  , 25 [i=4,j=2]  , 34 [i=4,j=3]  , 33 [i=4,j=4]  , 24 [i=4,j=5]  , 
<font style="color:red">这里没有介绍`while`和`do~while`循环的数组遍历方式，请自行思考。</font>
### __静态数组和动态数组（集合）__
在Java语言的学习中学习的数组都是静态数组，其实在很多的时候，静态数组根本不能满足我们编程的实际需要，比方说我需要在程序运行过程中动态的向数组中添加数据，这时我们的静态数组大小是固定的，显然就不能添加数据，要动态添加数据必须要用到动态数组，动态数组中的各个元素类型也是一致的，不过这种类型已经是用一个非常大的类型来揽括—Object类型。Object类是java.lang包中的顶层超类。所有的类型都可以与Object类型兼容，所以我们可以将任何Object类型添加至属于Object类型的数组中，能添加Object类型的的集合有ArrayList、Vector及LinkedList，它们对数据的存放形式仿造于数组，属于集合类，下面是他们的特点：
#### __特点一、容量扩充性__
从内部实现机制来讲ArrayList和Vector都是使用Object的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%，所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。
#### __特点二、同步性__
ArrayList，LinkedList是线程不同步的，而Vestor是线程安全的。所以如果要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。
### __特点三、数据操作效率__
ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList、ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法(线程安全)所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快。

### __实验__

目的：理解Java中Array的用法<br/>
环境：Eclipse环境

* 实验1：书写一段代码，定义和初始化各种不同一维数组
* 实验2：书写一段代码，定义和初始化各种不同二维数组
* 实验3：书写一段代码，使用while遍历一维数组和二维数组
* 实验4：书写一段代码，使用do~while遍历一维数组和二维数组
* 思考：如何实现二维数组的“列遍历”算法
* 思考：复杂类型的数组内存结构是什么？（等OO学完了回过头来看复杂类型的数组）

### __测试用例__
类清单：<br/>
被测试类：

* `com.sco._1st.test.ArrayCase`

测试用例：

* `com.sco._1st.test.ArrayTestCase`